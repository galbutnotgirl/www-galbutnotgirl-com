/*!
 * contentstack-express
 * copyright (c) Built.io Contentstack
 * MIT Licensed
 */

'use strict';

/**
 * Module Dependencies.
 */

var _ = require('lodash'),
    async = require('async'),
    sift = require('sift'),
    //helper = require('./../../../app/utils/helper'),
    config = require('./../config/index'),
    languages = config.get('languages');

var utility = {};

module.exports = exports = utility;

// _query to overrite the search on reference
exports.filterQuery = function (_query, build) {
    // remove the unwanted keys from the query
    var __keys = ["locale", "_remove", "include_references", "include_count", "_include_previous", "_include_next"];
    for(var i = 0, total = __keys.length; i < total; i++) {
        delete _query[__keys[i]];
    }

    // search for the reference
    var _filterQuery = function (query) {
        for (var key in query) {
            var _keys = (key) ? key.split('.') : [],
                _index = (_keys && _keys.length) ? _keys.indexOf('uid') : -1;
            if (_index > 1) {
                var _value = query[key];
                _keys[_index] = "values";
                var _key = _keys.join('.');
                query[_key] = _value;
                delete query[key];
            } else if (query[key] && typeof query[key] == "object") {
                _filterQuery(query[key]);
            }
        }
    };

    if(!build) _filterQuery(_query);
    return _query;
};

exports.updateAssetUrl = function(data, _language){
    return data;
};

exports.merge = function(destination, source) {
    if(source && destination) {
        for(var key in source) {
            if(source[key]) destination[key] = source[key];
        }
    }
    return destination;
}

exports.filterSchema = function(_forms, _remove) {
    var _keys = ['schema'].concat(_remove || []);
    var _removeKeys = function(object) {
        for(var i = 0, total = _keys.length; i < total; i++) {
            delete object[_keys[i]];
        }
        return object;
    };

    if(_forms && _forms instanceof Array) {
        for(var i = 0, total = _forms.length; i < total; i++) {
            if(_forms[i] && _forms[i]['_data']) {
                _forms[i]['_data'] = _removeKeys(_forms[i]['_data']);
            }
        }
    } else if(_forms && typeof _forms == "object") {
        _forms['_data'] = _removeKeys(_forms['_data']);
    }
    return _forms;
};

exports.findReferences = function(contentType) {
    if(contentType && contentType.schema && contentType.schema.length) {
        var _data = {},
            _keys = ["title", "uid", "schema", "options", "singleton", "references", "created_at", "updated_at"];

        var _removeKeys = function(contentType) {
            for(var _field in contentType) {
                if(_keys.indexOf(_field) == -1) {
                    delete contentType[_field];
                }
            }
            return contentType;
        }

        var _findReferences = function(_schema, parent) {
            for(var i = 0, total = _schema.length; i < total; i++) {
                var parentKey;
                if(_schema[i] && _schema[i]['data_type'] && _schema[i]['data_type'] == "reference") {
                    var field = ((parent) ? parent + ":" +_schema[i]['uid'] : _schema[i]['uid']);
                    _data[field] = _schema[i]['reference_to'];
                } else if(_schema[i] && _schema[i]['data_type'] && _schema[i]['data_type'] == "group" && _schema[i]['schema']) {
                    _findReferences(_schema[i]['schema'], ((parent) ? parent + ":" +_schema[i]['uid'] : _schema[i]['uid']));
                }
            }
        };

        contentType = _removeKeys(contentType);

        _findReferences(contentType.schema, "_data");
        // adding or recalculating the references of the form
        contentType['references'] = _data;
    }
    return contentType;
};

exports.filterEntries = function(content_type_id, fields, _entries) {
    if(_entries && fields && fields.length) {
        var _default = ['uid'];

        fields = _.uniq(fields.concat(_default));

        var _filterData = function(_entry) {
            var entry = {"_uid": _entry["_uid"], "_data": {}, "_content_type_uid": content_type_id};
            for(var f = 0, _f = fields.length; f < _f; f++) {
                entry["_data"][fields[f]] = _entry["_data"][fields[f]];
            }
            return entry;
        };

        if(_entries instanceof Array) {
            for(var i = 0, total = _entries.length; i < total; i++) {
                _entries[i] = _filterData(_entries[i]);
            }
        } else if(_entries && typeof _entries == "object"){
            _entries = _filterData(_entries);
        }
    }
    return _entries;
};

exports.queryBuilder = function(query, language, content_type_id, callback) {
    var skipFormIds = ["_routes", "_content_types"];

    if(query && Object.keys(query).length && content_type_id && skipFormIds.indexOf(content_type_id) == -1) {
        var Inmemory = require('./inmemory/index'),
            schema = Inmemory.get(language, "_content_types", {_uid: content_type_id}),
            references = {};

        if(schema && schema.length) {
            schema = schema[0];
            references = schema.references || {};
        }

        // check if the reference exists in the system
        if(Object.keys(references).length > 0) {
            var requests = [];
            for(var filterField in query) {
                requests.push(function(filterField) {
                    return function(_callback) {
                        var _calls = {};
                        var _filterField = filterField.toString();
                        var refQuery, refForm;

                        for (var refField in references) {
                            var newRefField = refField.replace(/:/g, ".");
                            if (filterField.indexOf(newRefField) == 0) {
                                // processing the new query param
                                _filterField = _filterField.split('.');
                                _filterField[_filterField.length - 1] = "uid";
                                _filterField = _filterField.join(".");

                                refForm = references[refField];
                                refQuery = refQuery || {};
                                var newFilterField = filterField.replace(newRefField, "_data");  // remove this entry, replacement if system going to attach the "_data."
                                refQuery[newFilterField] = query[filterField];
                                delete query[filterField];
                            }
                        }

                        if (refQuery && Object.keys(refQuery).length) {
                            _calls[_filterField] = (function (refQuery, content_type_id) {
                                return function (_cb) {
                                    var RefData = Inmemory.get(language, content_type_id, refQuery),
                                        RefQuery = {"$in": []};
                                    if(RefData && RefData.length) RefQuery = {"$in": _.pluck(RefData, "uid")};
                                    _cb(null, RefQuery);
                                }
                            }(refQuery, refForm));
                        } else if (_.isArray(query[filterField])) {
                            var __calls = [];
                            for (var i = 0, total = query[filterField].length; i < total; i++) {
                                __calls.push(function (filterQuery) {
                                    return function (__cb) {
                                        utility.queryBuilder(filterQuery, language, content_type_id, __cb);
                                    }
                                }(query[filterField][i]));
                            }

                            _calls[filterField] = (function (__calls) {
                                return function (_cb) {
                                    async.parallel(__calls, _cb);
                                }
                            }(__calls));
                        }

                        if (Object.keys(_calls).length) {
                            async.parallel(_calls, _callback);
                        } else {
                            var _temp = {};
                            _temp[filterField] = query[filterField];
                            _callback(null, _temp);
                        }
                    }
                }(filterField));
            }

            async.parallel(requests, function(err, result) {
                var __query = {};
                for(var i = 0, total = result.length; i < total; i++) {
                    _.merge(__query, result[i]);
                }
                callback(null, __query);
            });
        } else {
            callback(null, query);
        }
    } else {
        callback(null, query);
    }
};

exports.getContentPath = function(langCode) {
    var idx = _.findIndex(languages, {"code": langCode});
    if(~idx) {
        return languages[idx]['contentPath'];
    } else {
        console.error("Language doesn't exists");
    }
};
