/*!
 * contentstack-express
 * copyright (c) Built.io Contentstack
 * MIT Licensed
 */

'use strict';

/**
 * Module Dependencies.
 */
var sift = require('sift'),
    path = require('path'),
    fs = require('fs'),
    events = require('events').EventEmitter,
    util = require('util'),
    _ = require('lodash'),
    async = require('async'),
    config = require('./../../config/index'),
    languages = config.get('languages'),
    helper = require('./../helper'),
    InMemory = require('./../inmemory/index');

var fileStorage = function () {
    // Inherit methods from EventEmitter
    events.call(this);

    // Remove memory-leak warning about max listeners
    this.setMaxListeners(0);

    // Keep track of spawned child processes
    this.childProcesses = [];

    this.isEndsWith = function (str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };

    // Bind `this` context for all `fileStorage.prototype.*` methods
    this.findOne = _.bind(this.findOne, this);
    this.find = _.bind(this.find, this);
    this.count = _.bind(this.count, this);
    this.insert = _.bind(this.insert, this);
    this.upsert = _.bind(this.upsert, this);
    this.remove = _.bind(this.remove, this);
    this.sortByKey = _.bind(this.sortByKey, this);
};
// Extend from EventEmitter to allow hooks to listen to stuff
util.inherits(fileStorage, events);

// include references
fileStorage.prototype.includeReferences = function (data, _locale, callback) {
    var self = this,
        calls = [];
    var _includeReferences = function (data) {
        for (var _key in data) {
            if (typeof data[_key] == "object") {
                if (data[_key] && data[_key]["_content_type_id"]) {
                    calls.push(function (_key, data) {
                        return (function (_callback) {
                            var query = {"_content_type_uid": data[_key]["_content_type_id"], "_uid": {"$in": data[_key]["values"]},"locale": _locale},
                                _calls = [];
                            _calls.push(function (field, query) {
                                return (function (cb) {
                                    self.find(query, {}, function (_err, _data) {
                                        if (!_err) {
                                            if (_data) {
                                                var __data = [];
                                                for (var a = 0, _a = query._uid.$in.length; a < _a; a++) {
                                                    var _d = _.find(_data, {uid: query._uid.$in[a]});
                                                    if (_d) __data.push(_d);
                                                }
                                                data[field] = __data;
                                            } else {
                                                data[field] = [];
                                            }
                                            return setImmediate(function () {
                                                return cb(null, data)
                                            });
                                        } else {
                                            return setImmediate(function () {
                                                return cb(_err, null);
                                            });
                                        }
                                    });
                                });
                            }(_key, query));
                            async.series(_calls, function (__err, __data) {
                                return setImmediate(function () {
                                    return _callback(__err, __data);
                                });
                            });
                        });
                    }(_key, data));
                } else {
                    _includeReferences(data[_key]);
                }
            }
        }
    };

    var recursive = function (data, callback) {
        _includeReferences(data);
        if (calls.length) {
            async.series(calls, function (e, d) {
                if (e) throw e;
                calls = [];
                return setImmediate(function () {
                    return recursive(data, callback);
                });
            });
        } else {
            callback(null, data);
        }
    };

    try {
        recursive(data, callback);
    } catch (e) {
        callback(e, null);
    }
};

// find single entry
fileStorage.prototype.findOne = function (query, _callback) {
    try {
        var _query = _.clone(query, true),
            self = this;
        if (_query && typeof _query == "object") {
            // get the locale
            var language = _query.locale,
                model = helper.getContentPath(language),
                remove = _query._remove || false,
                includeReference = (typeof _query.include_references == 'undefined' || _query.include_references == true) ? true : false,
                options = {},
                contentTypeId = _query._content_type_uid,
                jsonPath = (contentTypeId) ? path.join(model, contentTypeId + ".json") : null;

            options["previous"] = _query._include_previous
            options["next"] = _query._include_next;

            // to remove the unwanted keys from query and create reference query
            _query = helper.filterQuery(_query);

            if (jsonPath && fs.existsSync(jsonPath)) {
                fs.readFile(jsonPath, 'utf-8', function(err, models) {
                    if(err) throw err;
                    var data, _data;
                    models = JSON.parse(models);
                    // apply the query to data to filter entries
                    if(models && models.length) data = sift(_query, models);
                    // get the single entry fromt he filtered set of entries
                    if (data && data.length) data = data[0];
                    if(data && data._data) {
                        _data = data._data; // if user request for the entry wrapper
                        var _calls = {}, _newQuery, entryCallback;
                        //new query for _include_previous & _include_next for the findOne option to get next and previous
                        _newQuery = {query: _query, locale: language, entry: data._data, content_type_id: contentTypeId};
                        // remove the entry wrapper
                        if (remove) _data = data;

                        entryCallback = function(entryData, entryLocale, cb1) {
                            if (includeReference) {
                                self.includeReferences(entryData, entryLocale, cb1);
                            } else {
                                cb1(null, entryData);
                            }
                        }

                        for(var order in options) {
                            if(options[order] && options[order].length) {
                                _calls[order] = (function (order, sort) {
                                    return function (__cb) {
                                        self.navigation(order, sort, _newQuery, __cb);
                                    }
                                }(order, options[order]));
                            }
                        }

                        if(Object.keys(_calls).length) {
                            _calls["entry"] = function(__cb) {
                                entryCallback(_data, language, __cb);
                            }
                            // running all the queries parallely
                            async.parallel(_calls, _callback);
                        } else {
                            entryCallback(_data, language, _callback);
                        }
                    } else {
                        _callback(null, null);
                    }
                });
            } else {
                _callback(null, null);
            }
        } else {
            throw new Error("query parameter should be an object.");
        }
    } catch (e) {
        _callback(e, null);
    }
};

// find and sort(optional) entries using query
fileStorage.prototype.find = function () {
    var model,
        language,
        _count,
        self = this,
        includeReference;

    var findOnly = function (query, _callback) {
        try {
            var _query = _.clone(query, true), locale, jsonPath;
            if (_query && typeof _query == "object") {
                // get the locale
                language = _query.locale;
                model = helper.getContentPath(language);
                includeReference = (typeof _query.include_references == 'undefined' || _query.include_references == true) ? true : false;
                if (_query._content_type_uid) jsonPath = path.join(model, _query._content_type_uid + ".json");

                // to remove the unwanted keys from query and create reference query
                _query = helper.filterQuery(_query);

                if (jsonPath && fs.existsSync(jsonPath)) {
                    fs.readFile(jsonPath, 'utf-8', function(err, models) {
                        if(err) throw err;
                        models = JSON.parse(models);
                        cb(sift(_query, models), true, _callback);
                    });
                } else {
                    _callback(null, []);
                }
            } else {
                throw new Error("query parameter should be an object.");
            }
        } catch (e) {
            _callback(e, null);
        }
    };

    var findSort = function (query, options, _callback) {
        try {
            if (query && typeof query == "object" && typeof options == "object") {
                var _query = _.clone(query) || {},
                    sort = options.sort || {},
                    locale;

                // include_count prameter
                _count = _query.include_count || false;
                // get the locale
                language = _query.locale;
                // include the references after the sorting and limit options happens
                includeReference = (typeof _query.include_references == 'undefined' || _query.include_references == true) ? true : false;
                _query.include_references = false;
                _query.include_count = false;

                self.find(_query, function (err, data) {
                    if (err) throw err;
                    var keys = Object.keys(sort),
                        __sort = {keys: [], order: []};
                    for (var i = 0, total = keys.length; i < total; i++) {
                        var __order = (sort[keys[i]] == 1) ? 'asc' : 'desc';
                        // removing the _data. key to make the default sorting work
                        __sort.keys.push(keys[i].replace('_data.', ''));
                        __sort.order.push(__order);
                    }
                    data = _.sortByOrder(data, __sort.keys, __sort.order);
                    if (options.limit) {
                        options.skip = (options.skip) ? (options.skip) : 0;
                        data = data.splice(options.skip, options.limit);
                    }
                    if(_count) {
                        self.count(_query, function(err, result) {
                            cb({entries: data, count: result}, false, _callback);
                        });
                    } else {
                        cb(data, false, _callback);
                    }
                });
            } else {
                throw new Error("query and options parameters should be objects.");
            }
        } catch (e) {
            _callback(e, null);
        }
    };

    var cb = function (data, pluck, callback) {
        if (data) {
            var _data = (pluck) ? _.pluck(data, "_data") : data;
            if (includeReference) {
                self.includeReferences(_data, language, function(err, results) {
                    if(err) {
                        callback(err);
                    } else {
                        callback(null, results);
                    }
                });
            } else {
                callback(null, _data);
            }
        } else {
            callback(null, null);
        }
    };

    if (arguments.length == 2) {
        return (findOnly.apply(this, arguments));
    } else if (arguments.length == 3) {
        return (findSort.apply(this, arguments));
    }
};

// find entries count
fileStorage.prototype.count = function (query, callback) {
    try {
        if (query && typeof query == "object") {
            // adding the include_references just to get the count
            query.include_references = false;
            query.include_count = false;
            this.find(query, function (err, data) {
                if (err) throw err;
                callback(null, data.length);
            });
        } else {
            throw new Error("query parameter should be an object.");
        }
    } catch (e) {
        callback(e, null);
    }
};

// add entry in to db
fileStorage.prototype.insert = function (data, callback) {
    try {
        if (data && typeof data == "object" && data._content_type_uid && data._uid) {
            var language = data.locale,
                model = helper.getContentPath(language),
                contentTypeId = data._content_type_uid,
                jsonPath = path.join(model, contentTypeId + ".json"),
                entries = [];

            // to remove the unwanted keys from query/data
            data = helper.filterQuery(data, true);

            var _callback = function(filePath, _entries, _cb) {
                fs.writeFile(filePath, JSON.stringify(_entries), function(err) {
                    if(err) throw err;
                    _cb(null, 1);
                });
            };

            // updating the references based on the new schema
            if(contentTypeId == "_content_types") data['_data'] = helper.findReferences(data['_data']);
            if (fs.existsSync(jsonPath)) {
                fs.readFile(jsonPath, 'utf-8', function(err, entries) {
                    if(err) throw err;
                    entries = JSON.parse(entries) || [];
                    var idx = _.findIndex(entries, {'_uid': data._uid});
                    if(~idx) {
                        callback(new Error("Data already exists, use upsert instead of insert."), null);
                    } else {
                        InMemory.set(language, contentTypeId, data._uid, data);
                        entries.unshift(data);
                        _callback(jsonPath, entries, callback);
                    }
                });
            } else {
                InMemory.set(language, contentTypeId, data._uid, data);
                _callback(jsonPath, [data], callback);
            }
        } else {
            throw new Error("data should be an object with at least content_type_id and _uid.");
        }
    } catch (e) {
        callback(e, null);
    }
};

// find entry, if found then update else insert
fileStorage.prototype.upsert = function (data, callback) {
    try {
        if (data && typeof data == "object" && data._content_type_uid && data._uid) {
            var entries = [],
                _query = _.clone(data, true),
                contentTypeId = _query._content_type_uid,
                language = _query.locale,
                model = helper.getContentPath(language),
                jsonPath = path.join(model, contentTypeId + ".json");

            // to remove the unwanted keys from query/data and create reference query
            _query = helper.filterQuery(_query, true);

            var _callback =  function(_jsonPath, __data, _cb) {
                fs.writeFile(jsonPath, JSON.stringify(__data), function(err) {
                    if(err) throw err;
                    _cb(null, 1);
                });
            };

            // updating the references based on the new schema
            if(contentTypeId === '_content_types') _query['_data'] = helper.findReferences(_query['_data']);
            if (fs.existsSync(jsonPath)) {
                fs.readFile(jsonPath, 'utf-8', function(err, entries) {
                    if(err) throw err;
                    entries = JSON.parse(entries);
                    var idx = _.findIndex(entries, {"_uid": _query._uid});
                    if(idx != -1) entries.splice(idx, 1);
                    entries.unshift(_query);
                    InMemory.set(language, contentTypeId, _query._uid, _query);
                    _callback(jsonPath, entries, callback);
                });
            } else {
                InMemory.set(language, contentTypeId, _query._uid, _query);
                _callback(jsonPath, [_query], callback);
            }
        } else {
            throw new Error("data should be an object with at least content_type_id and _uid.");
        }
    } catch (e) {
        callback(e, null);
    }
};

// delete entry from db
fileStorage.prototype.bulkInsert = function (query, callback) {
    try {
        if(query && typeof query == "object" && query._content_type_uid && query.entries) {
            var entries = query.entries || [],
                contentTypeId = query._content_type_uid,
                language = query.locale,
                model = helper.getContentPath(language),
                jsonPath = path.join(model, contentTypeId + ".json"),
                _entries = [];

            for(var i = 0, total = entries.length; i < total; i++) {
                _entries.push({
                    _data: entries[i],
                    _content_type_uid: contentTypeId,
                    _uid: entries[i]['uid'] || entries[i]['entry']['uid'] // entry is just for the _routes
                });
            }

            fs.writeFile(jsonPath, JSON.stringify(_entries), function(err) {
                if(err) throw err;
                InMemory.set(language, contentTypeId, null, _entries);
                callback(null, 1);
            });
        } else {
            throw new Error("query should be an object with at least content_type_id and entries.");
        }
    } catch (e) {
        callback(e, null);
    }
};

// delete entry from db
fileStorage.prototype.remove = function (query, callback) {
    try {
        if (query && typeof query == "object") {
            var content_type_id,
                language = query.locale,
                contentTypeId = query._content_type_uid,
                _query = _.clone(query, true),
                model = helper.getContentPath(language),
                jsonPath = path.join(model, contentTypeId + ".json");

            if(!fs.existsSync(jsonPath)) {
                callback(null, 1);
            } else {
                if (Object.keys(_query).length === 2 && contentTypeId && language) {
                    fs.unlink(jsonPath, function(err) {
                        if(err) throw err;
                        InMemory.set(language, contentTypeId, null, []);
                        callback(null, 1);
                    });
                } else if (contentTypeId) {
                    var idx, entries, idxData;
                    // remove the unwanted keys from query/data
                    _query = helper.filterQuery(_query);

                    fs.readFile(jsonPath, 'utf-8', function(err, entries) {
                        if(err) throw err;
                        entries = JSON.parse(entries);
                        idx = _.findIndex(entries, {"_uid": _query._uid});
                        if (~idx) entries.splice(idx, 1);
                        fs.writeFile(jsonPath, JSON.stringify(entries), function(err) {
                            if(err) throw err;
                            InMemory.set(language, contentTypeId, _query._uid);
                            callback(null, 1);
                        });
                    });
                } else {
                    callback(null, null);
                }
            }
        } else {
            throw new Error("query parameter should be an object.");
        }
    } catch (e) {
        callback(e, null);
    }
};


// previous will get the details based on the sort options
fileStorage.prototype.navigation = function(order, sort, query, callback) {
    try {
        if(order && query && typeof query == "object" && query.query && query.entry) {
            var _query = _.clone(query.query, true),
                _entry = query.entry,
                __query,
                _operator = (order == "previous") ? "$lte" : "$gte",
                __sort = {};

            _query.locale = query.locale;
            // remove the optional queries from the cloned query
            delete _query.entry_id;

            __query = _query;
            __query["_uid"] = {"$nin": [_entry.uid]};
            __query["content_type_id"] = query.content_type_id;

            // add the queries to find the previous items
            for(var i = 0, total = sort.length; i < total; i++) {
                __sort[sort[i]] = (order == "previous") ? -1 : 1;
                __query["_data."+sort[i]] = __query["_data."+sort[i]] || {};
                __query["_data."+sort[i]][_operator] =  _entry[sort[i]];
            }
            this.find(__query, {sort: __sort, limit: 1, skip: 0}, function(err, result) {
                if(err) throw err;
                result = (result && result.length) ? result.pop() : null;
                callback(null, result);
            });
        } else {
            throw new Error("Provide valid object to find previous/next entry");
        }
    } catch(e) {
        callback(e);
    }
};

// custom sort function
fileStorage.prototype.sortByKey = function (array, key, asc) {
    var _keys = key.split('.'),
        len = _keys.length;

    return array.sort(function (a, b) {
        var x = a, y = b;
        for (var i = 0; i < len; i++) {
            x = x[_keys[i]];
            y = y[_keys[i]];
        }
        if (asc) {
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        }
        return ((y < x) ? -1 : ((y > x) ? 1 : 0));
    });
};

exports = module.exports = new fileStorage();
