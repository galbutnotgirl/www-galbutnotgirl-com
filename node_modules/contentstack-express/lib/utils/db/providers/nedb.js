/*!
 * contentstack-express
 * copyright (c) Built.io Contentstack
 * MIT Licensed
 */

'use strict';

/**
 * Module Dependencies.
 */
var datastore = require('nedb'),
    path = require('path'),
    fs = require('fs'),
    events = require('events').EventEmitter,
    util = require('util'),
    _ = require('lodash'),
    async = require('async'),
    config = require('./../../config/index'),
    languages = config.get('languages'),
    helper = require('./../helper'),
    fileStorage = require('./FileSystem'),
    skipForms = ["_routes", "_content_types", "_multiple_routes"];

var nedbStorage = function () {
    // Inherit methods from EventEmitter
    events.call(this);

    // Remove memory-leak warning about max listeners
    this.setMaxListeners(0);

    // Keep track of spawned child processes
    this.childProcesses = [];

    this.db = {};

    var self = this,
        databases = {};
    for (var l = 0, lTotal = languages.length; l < lTotal;l++) {
        databases[languages[l]['code']] = (function (language) {
            return function (cb) {
                self.db[language.code] = new datastore({inMemoryOnly: true});
                var model = language.contentPath;
                if (fs.existsSync(model)) {
                    fs.readdir(model, function (err, files) {
                        if (err) {
                            cb(err, null);
                        } else {
                            var loadDatabase = [];
                            for (var i = 0, total = files.length; i < total; i++) {
                                var fileName = files[i].replace('.json', '');
                                if(skipForms.indexOf(fileName) == -1) {
                                    loadDatabase.push(function (i, filePath) {
                                        return function (_cb) {
                                            fs.readFile(path.join(model, filePath), 'utf-8', function (err, data) {
                                                if (err) _cb(err);
                                                data = JSON.parse(data);
                                                self.db[language.code].insert(data, _cb);
                                            });
                                        }
                                    }(i, files[i]));
                                }
                            }
                            async.parallel(loadDatabase, function (err, res) {
                                if (err) {
                                    cb(err, res);
                                } else {
                                    self.db[language.code].ensureIndex({
                                        fieldName: '_uid',
                                        unique: true,
                                        sparse: true
                                    }, cb);
                                }
                            });
                        }
                    });
                } else {
                    cb(null, {});
                }
            }
        }(languages[l]))
    }

    async.parallel(databases, function (err, res) {
        if (err) {
            console.error("Database Couldn't load :" + err.message);
            process.exit(0);
        }
    });

    // Bind `this` context for all `nedbStorage.prototype.*` methods
    this.findOne = _.bind(this.findOne, this);
    this.find = _.bind(this.find, this);
    this.count = _.bind(this.count, this);
    this.insert = _.bind(this.insert, this);
    this.bulkInsert = _.bind(this.bulkInsert, this);
    this.upsert = _.bind(this.upsert, this);
    this.remove = _.bind(this.remove, this);
};
// Extend from EventEmitter to allow hooks to listen to stuff
util.inherits(nedbStorage, events);

// include references
nedbStorage.prototype.includeReferences = function (data, _locale, callback) {
    var self = this,
        calls = [];
    var _includeReferences = function (data) {
        for (var _key in data) {
            if (typeof data[_key] == "object") {
                if (data[_key] && data[_key]["_content_type_id"]) {
                    calls.push(function (_key, data) {
                        return (function (_callback) {
                            var query = {"_content_type_uid": data[_key]["_content_type_id"], "_uid": {"$in": data[_key]["values"]}, "locale": _locale},
                                _calls = [];
                            _calls.push(function (field, query) {
                                return (function (cb) {
                                    self.find(query, function (_err, _data) {
                                        if (!_err) {
                                            if (_data) {
                                                data[field] = _data;
                                            } else {
                                                data[field] = [];
                                            }
                                            return setImmediate(function () {
                                                return cb(null, data)
                                            });
                                        } else {
                                            return setImmediate(function () {
                                                return cb(_err, null);
                                            });
                                        }
                                    });
                                });
                            }(_key, query));
                            async.series(_calls, function (__err, __data) {
                                return setImmediate(function () {
                                    return _callback(__err, __data);
                                });
                            });
                        });
                    }(_key, data));
                } else {
                    _includeReferences(data[_key]);
                }
            }
        }
    };

    var recursive = function (data, callback) {
        _includeReferences(data);
        if (calls.length) {
            async.series(calls, function (e, d) {
                if (e) throw e;
                calls = [];
                return setImmediate(function () {
                    return recursive(data, callback);
                });
            });
        } else {
            callback(null, helper.updateAssetUrl(data, _locale));
        }
    };

    try {
        recursive(data, callback);
    } catch (e) {
        callback(e, null);
    }
};

// find single entry
nedbStorage.prototype.findOne = function (query, callback) {
    try {
        var _query = _.clone(query, true),
            self = this,
            locale;
        if (_query && typeof _query == "object") {
            locale = _query.locale;
            var remove = _query._remove || false,
                includeReference = (typeof _query.include_references == 'undefined' || _query.include_references == true) ? true : false,
                options = {},
                contentTypeId = _query.content_type_id;
            options["previous"] = _query._include_previous
            options["next"] = _query._include_next;

            // to remove the unwanted keys from query
            _query = helper.filterQuery(_query);

            this.db[locale].findOne(_query).sort({"_data.published_at": -1}).exec(function (err, data) {
                if (err) {
                    throw err;
                } else if(data && data._data) {
                    // check if data exists then only search for more
                    var _calls = {}, _newQuery, _data = data._data;
                    //new query for _include_previous & _include_next for the findOne option to get next and previous
                    _newQuery = {query: _query, locale: locale, entry: data._data, content_type_id: contentTypeId};

                    if (remove) _data = data;

                    var entryCallback = function(entryData, entryLocale, cb1) {
                        if (includeReference) {
                            self.includeReferences(entryData, entryLocale, cb1);
                        } else {
                            cb1(null, helper.updateAssetUrl(entryData), locales[entryLocale]);
                        }
                    }

                    for(var order in options) {
                        if(options[order] && options[order].length) {
                            _calls[order] = (function (order, sort) {
                                return function (__cb) {
                                    self.navigation(order, sort, _newQuery, __cb);
                                }
                            }(order, options[order]));
                        }
                    }

                    var __data = _.clone(_data, true);
                    if(Object.keys(_calls).length) {
                        _calls["entry"] = function(__cb) {
                            entryCallback(__data, locale, __cb);
                        }
                        // running all the queries parallely
                        async.parallel(_calls, callback);
                    } else {
                        entryCallback(__data, locale, callback);
                    }
                } else {
                    callback(null, null);
                }
            });
        } else {
            throw new Error("query parameter should be an object.");
        }
    } catch (e) {
        callback(e, null);
    }
};

// find and sort(optional) entries using query
nedbStorage.prototype.find = function () {
    var locale,
        self = this,
        _count,
        includeReference;

    var findOnly = function (query, callback) {
        try {
            var _query = _.clone(query, true);
            if (_query && typeof _query == "object") {
                locale = _query.locale;
                includeReference = (typeof _query.include_references == 'undefined' || _query.include_references == true) ? true : false;

                // to remove the unwanted keys from query and create reference query
                _query = helper.filterQuery(_query);

                self.db[locale].find(_query).sort({"_data.published_at": -1}).exec(function (err, data) {
                    return cb(err, data, callback)
                });
            } else {
                throw new Error("query parameter should be an object.");
            }
        } catch (e) {
            callback(e, null);
        }
    };

    var findSort = function (query, options, callback) {
        try {
            var _query = _.clone(query, true);
            if (_query && typeof _query == "object" && typeof options == "object") {
                var sort = options.sort || {},
                    calls = {};
                locale = _query.locale;

                includeReference = (typeof _query.include_references == 'undefined' || _query.include_references == true) ? true : false;
                _count = _query.include_count;

                // to remove the unwanted keys from query and create reference query
                _query = helper.filterQuery(_query);

                if (options.limit) {
                    options.skip = options.skip || 0;
                    calls['entries'] = function(_cb) {
                        self.db[locale].find(_query).sort(sort).skip(options.skip).limit(options.limit).exec(_cb);
                    }
                } else {
                    calls['entries'] = function(_cb) {
                        self.db[locale].find(_query).sort(sort).exec(_cb);
                    }
                }
                if(_count) {
                    calls['count'] = function(_cb) {
                        self.db[locale].count(_query, _cb);
                    }
                }
                async.parallel(calls, function(err, result) {
                    if(!_count && result && result['entries']) result = result['entries'];
                    return cb(err, result, callback);
                });
            } else {
                throw new Error("query and options parameters should be objects.");
            }
        } catch (e) {
            callback(e, null);
        }
    };

    var cb = function (err, data, callback) {
        if (err) throw err;
        if (data) {
            var _data = {};
            if(_count) {
                _data.entries = _.pluck(_.clone(data.entries, true), "_data");
                _data.count = data.count;
            } else {
                _data = _.pluck(data, "_data");
            }
            if (includeReference) {
                self.includeReferences(_data, locale, function(err, results) {
                    if(err) {
                        callback(err);
                    } else {
                        callback(null, results);
                    }
                });
            } else {
                callback(null, _data);
            }
        } else {
            callback(null, null);
        }
    };

    if (arguments.length == 2) {
        return (findOnly.apply(this, arguments));
    } else if (arguments.length == 3) {
        return (findSort.apply(this, arguments));
    }
};

// find entries count
nedbStorage.prototype.count = function (query, callback) {
    try {
        if (query && typeof query == "object") {
            var locale = query.locale;
            // to remove the unwanted keys from query and create reference query
            query = helper.filterQuery(query);
            this.db[locale].count(query, callback);
        } else {
            throw new Error("query parameter should be an object.");
        }
    } catch (e) {
        callback(e, null);
    }
};

// add entry in to db
nedbStorage.prototype.insert = function (data, callback) {
    try {
        var self = this,
            contentTypeId = data._content_type_uid.toString(),
            language = data.locale;
        fileStorage.insert(data, function (err, res) {
            try {
                if (err) throw err;
                // remove the unwanted keys from the local-storage data
                data = helper.filterQuery(data, true);
                data._uid = data._uid || data._data.uid;
                if (contentTypeId == "_routes" || contentTypeId == "_content_types") {
                    callback(null, res);
                } else {
                    self.db[language].insert(data, callback);
                }
            } catch (e) {
                callback(e, null);
            }
        });
    } catch (e) {
        callback(e, null);
    }
};

// find entry, if found then update else insert
nedbStorage.prototype.upsert = function (data, callback) {
    try {
        var self = this,
            language = data.locale;
        fileStorage.upsert(data, function (err, result) {
            if (err) throw err;
            // remove the unwanted keys
            data = helper.filterQuery(data, true);
            data._uid = data._uid || data._data.uid;
            if (data.content_type_id == "_routes") {
                callback(null, result);
            } else {
                self.db[language].update({_uid: data._uid}, data, {upsert: true}, callback);
            }
        });
    } catch (e) {
        callback(e, null);;
    }
};

// delete entry from db
nedbStorage.prototype.remove = function (query, callback) {
    try {
        var self = this,
            language = query.locale;
        fileStorage.remove(query, function (err, res) {
            if (err) throw err;
            // to remove the unwanted keys from query and create reference query
            query = helper.filterQuery(query);
            if (query.content_type_id === "_routes") {
                callback(null, res);
            } else {
                self.db[language].remove(query, {}, callback);
            }
        });
    } catch (e) {
        callback(e, null);
    }
};

// bulk insert entries to db
nedbStorage.prototype.bulkInsert = function (query, callback) {
    try {
        var self = this;
        fileStorage.bulkInsert(query, function(err, result) {
            if(err) throw err;
            var entries = query.entries || [],
                calls = [],
                language = query.locale;
            for(var i = 0, total = entries.length; i < total; i++) {
                calls.push(function(entry) {
                    return function(cb) {
                        self.db[language].update({_uid: (entry.uid || entry.entry.uid)}, {_data: entry, _uid: (entry.uid || entry.entry.uid), _content_type_uid: query._content_type_uid}, {upsert: true}, cb);
                    }
                }(entries[i]));
            }
            async.parallelLimit(calls, 5, callback);
        });
    } catch (e) {
        callback(e, null);
    }
};

// previous will get the details based on the sort options
nedbStorage.prototype.navigation = function(order, sort, query, callback) {
    try {
        if(order && query && typeof query == "object" && query.query && query.entry) {
            var _query = _.clone(query.query, true),
                _entry = query.entry,
                __query,
                _operator = (order == "previous") ? "$lte" : "$gte",
                __sort = {};

            _query.locale = query.locale;
            _query.include_references = false;

            // remove the optional queries from the cloned query
            delete _query.entry;

            __query = _query;
            __query["_uid"] = {"$nin": [_entry.uid]};
            __query["content_type_id"] = query.content_type_id;

            // add the queries to find the previous/next items
            for(var i = 0, total = sort.length; i < total; i++) {
                __sort[sort[i]] = (order == "previous") ? -1 : 1;
                __query["_data."+sort[i]] = __query["_data."+sort[i]] || {};
                __query["_data."+sort[i]][_operator] =  _entry[sort[i]];
            }
            this.find(__query, {sort: __sort, limit: 1, skip: 0}, function(err, result) {
                if(err) throw err;
                result = (result && result.length) ? result.pop() : null;
                callback(null, result);
            });
        } else {
            throw new Error("Provide valid object to find previous entry");
        }
    } catch(e) {
        callback(e);
    }
};

exports = module.exports = new nedbStorage();
