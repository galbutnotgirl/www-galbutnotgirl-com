/*!
 * contentstack-express
 * copyright (c) Built.io Contentstack
 * MIT Licensed
 */

'use strict';

/**
 * Module Dependencies.
 */

var _ = require('lodash'),
    async = require('async'),
    sift = require('sift'),
    helper = require('./../helper'),
    context = require('./../../context'),
    datastore = require('./../providers/index'),
    Inmemory = require('./../inmemory/index');

var common = {
    updateField: function (field) {
        return "_data." + field;
    },
    compare: function(operator) {
        return function(field, value) {
            if (field && typeof value != "undefined" && typeof field === 'string') {
                field = common.updateField(field);
                this._query[field] = this._query[field] || {};
                if(operator){
                    this._query[field][operator] = value;
                } else {
                    this._query[field] = value;
                }
            } else {
                console.error("Please provide valid parameters for %s.", operator || "where");
            }
            return this;
        }
    },
    logical: function(operator) {
        return function(key, value) {
            this._query[operator] = this._query[operator] || [];
            if (key && value && typeof key == 'string') {
                var _query = {};
                key = common.updateField(key);
                _query[key] = value;
                this._query[operator].push(_query);
            } else {
                console.error("Please provide valid key and value parameters for %s.", operator, " Key should be string(field_uid)");
            }
            return this;
        }
    },
    containers: function(operator) {
        return function(field, values) {
            if (field && values && typeof field === 'string' && values instanceof Array) {
                field = common.updateField(field);
                this._query[field] = this._query[field] || {};
                this._query[field][operator] = values;
            } else {
                console.error("Please provide valid parameters for %s.", operator);
            }
            return this;
        }
    },
    sort: function(operator) {
        return function(field) {
            if (field && typeof field === 'string') {
                field = common.updateField(field);
                this._options['sort'] = this._options['sort'] || {};
                this._options['sort'][field] = operator;
            } else {
                console.error("Please provide valid sorting parameter.");
            }
            return this;
        }
    },
    exists: function(operator) {
        return function(field) {
            if (field && typeof field === 'string') {
                field = common.updateField(field);
                this._query[field] = this._query[field] || {};
                this._query[field]["$exists"] = operator;
            } else {
                console.error("Please provide valid parameters for exists.");
            }
            return this;
        }
    }
};

function Query() {
    this._query = {};
    this._options = {};
}

Query.prototype.where = common.compare();

Query.prototype.query = function(query) {
    if(query && typeof query === "object") {
        this._query = _.merge(this._query, query, function(src, dest) {
            if(_.isArray(src)) {
                return src.concat(dest);
            }
        });
    } else {
        console.error("Please provide the query of object type.");
    }
    return this;
};

Query.prototype.exists = common.exists(true);

Query.prototype.notExists = common.exists(false);

Query.prototype.notContainedIn = common.containers("$nin");

Query.prototype.containedIn = common.containers("$in");

Query.prototype.or = common.logical("$or");

Query.prototype.and = common.logical("$and");

Query.prototype.regex = common.compare("$regex");

Query.prototype.lessThan = common.compare("$lt");

Query.prototype.lessThan = common.compare("$lt");

Query.prototype.lessThanEqualTo = common.compare("$lte");

Query.prototype.greaterThan = common.compare("$gt");

Query.prototype.greaterThanEqualTo = common.compare("$gte");

Query.prototype.elementMatch = common.compare("$elemMatch");

Query.prototype.notEqualTo = common.compare("$ne");

Query.prototype.ascending = common.sort(1);

Query.prototype.descending = common.sort(-1);

Query.prototype.skip = function(skip) {
    this._options['skip'] = skip;
    return this;
};

Query.prototype.limit = function(limit) {
    this._options['limit'] = limit;
    return this;
};

Query.prototype.includePrevious = function(fields) {
    this._previous = fields || ["published_at"];
    return this;
};

Query.prototype.includeNext = function(fields) {
    this._next = fields || ["published_at"];
    return this;
};

Query.prototype.findOne = function(uid) {
    if(typeof uid == "string" && uid) this._uid = uid;
    this.single = true;
    return this;
};

Query.prototype.find = function() {
    return this;
};

Query.prototype.includeCount = function() {
    this.include_count = true;
    return this;
};

Query.prototype.excludeReference = function() {
    this._query = this._query || {};
    this._query.include_references = false;
    return this;
};

Query.prototype.count = function() {
    this._count = true;
    return this;
};

Query.prototype.then = function(success, error) {
    try {
        var result, self = this;

        // setting the locale
        this._locale = this._locale || context.get("locale") || "en-us";

        // setting the options
        var options = this._options || {};

        //setting the default sort option to publish_at descending
        options.sort = options.sort || {"_data.published_at": -1};

        var _query = _.clone(this._query, true);

        // new query Building
        helper.queryBuilder(_query, this._locale, this.content_type_id, function(err, resultQuery) {
            if(err) throw err;
            // to include the count of the final result
            if(self.include_count) resultQuery['include_count'] = true;
            _query = resultQuery;

            //creating query based on the chain methods
            _query = _.merge(_query, {_content_type_uid: self.content_type_id, locale: self._locale});
            if(self._uid) _query = _.merge(_query, {_uid: self._uid});

            var callback = function(err, data) {
                if(!err) {
                    success(data);
                } else {
                    error(err);
                }
            };

            var skipFormIds = ["_routes", "_content_types"];
            if(skipFormIds.indexOf(self.content_type_id) == -1) {
                if(self._uid || self.single) {
                    if(self._previous) _query._include_previous = self._previous;
                    if(self._next) _query._include_next = self._next;
                    datastore.findOne(_query, callback);
                } else if(self._count) {
                    datastore.count(_query, callback);
                } else {
                    datastore.find(_query, options, callback);
                }
            } else {
                var results = Inmemory.get(self._locale, self.content_type_id, _query);
                if(self._uid || self.single) {
                    results = (results.length) ? results[0] : null;
                } else if(self._count) {
                    results = results.length;
                }
                callback(null, results);
            }
        });
    } catch(err) {
        if(error && typeof error == "function") {
            error(err);
        } else {
            console.error("Error is not function: ", err.message);
        }
    }
}

module.exports = Query;
